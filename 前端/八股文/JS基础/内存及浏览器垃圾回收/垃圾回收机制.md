# 垃圾回收机制

#### 介绍：

垃圾收集器会定期（过程开销大，所以周期性执行）找出不再使用的变量，释放其内存。

##### 变量：

* 局部变量：只在函数执行过程中存在，而在这个过程会为局部变量在栈或堆上分配相应的空间，以存储他们的值，直至函数结束。（闭包中因为内部函数，外部函数并不能算结束）
* 全局变量：浏览器卸载页面才会结束

##### 标记清除

回收器运行时，先给所有存储在内存中的变量加上标记，然后会去掉在环境中的变量，以及被环境中变量引用的变量的标记。剩下的带标记的被视为准备删除的变量

##### 引用计数

每个值被引用的次数，每被引用一次+1，解除引用-1，当0的时候被清除

#### 回收策略

1. 分代回收

   > 1. **临时分区**
   >
   >    >简介：指在内存中存活时间比较短的对象
   >    >
   >    >包含：
   >    >
   >    >1. 函数内部申明的变量
   >    >2. 块级作用域中的变量
   >    >
   >    >V8:
   >    >
   >    >放在新生代区域，用副垃圾回收器处理
   >    >
   >    >> 副垃圾回收器：
   >    >>
   >    >> 容量1-8m，分为对象区域和空闲区域
   >    >>
   >    >> 1. 空的满了，就垃圾回收
   >    >> 2. 把空区域的内容放倒对象区域
   >    >> 3. 对对象区域标记
   >    >> 4. 把没标记的放回空闲 （有序排列不产生内存碎片）
   >    >> 5. 清理对象区域
   >
   > 2. **持久分区**
   >
   >    >简介：生命周期长的对象
   >    >
   >    >包含
   >    >
   >    >1. 全局window
   >    >2. DOM
   >    >3. Web API
   >    >4. 存在栈上的变量
   >    >
   >    >V8:
   >    >
   >    >放在老生代区域，用主垃圾回收器处理
   >    >
   >    >> 主垃圾回收器：
   >    >>
   >    >> 1. 使用标记-清除的算法
   >    >>
   >    >> 2. 从根元素循环，遍历这组元素，能达到的成为活动元素，不能达到的判断为垃圾数据，清理垃圾数据
   >    >> 3. 会产生内存碎片，需要内存整理

2. 增量GC

   每次处理一点，下次再处理一点

   特点：每次耗时短，但中断较多。（临时分区多的时候可，长期存活的对象多的时候，没什么优势）

3. 闲时GC

   值会在cpu空闲时运行，减少对代码执行的影响



## 不同类型变量的内存释放时机

1. 引用类型

   没有引用后回收

2. 值类型

   2.1. 如果处于闭包中，要等闭包没有引用才会被回收

   2.2. 非闭包，等v8新生代切换的时候回收

