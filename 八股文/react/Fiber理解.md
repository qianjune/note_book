## 1. react设计理念

#### 目标：快速响应

##### 制约因素

1. CPU的瓶颈
2. IO的瓶颈

##### Fiber

```
主要为了解决CPU和网络的问题
1. cpu造成卡顿
2. 网络造成白屏
react引入两个新概念来解决问题
1. Time Slicing时间分片
2. Suspense
```



## 2. 前天不足

### jsx

优势：具有js的完整表现力，用法灵活

劣势：局部渲染，无法从模版层面进行静态分析，过于灵活的预发让殷勤难以理解，判断开发者的意图，从而难以优化性能。

### template

优势：通过对静态template，和动态dom，做到预编译优化

劣势：编写约束，要遵守规则

## 3. 架构演化过程中做过哪些优化

### 15

> 两层架构
>
> 1. Reconciler（协商器）- 负责找出变化的组件
>
>    过程：采用低轨的方式创建虚拟DOM，过程不能中断
>
>    劣势：如果组件树层级较深，占用线程很多时间，超过16ms，用户交互会卡顿
>
> 2. Render（渲染器）- 负责将变化的组件渲染到页面上

### 16

> 三层架构
>
> 1. Scheduler（调度器）- 调度任务的优先级，高优任务优先进入Reconciler
> 2. Reconciler - 从递归变成可终端的循环过程，内部采用了Fiber架构

### 17

> 优化方便了优先级的计算，提供了批的概念
>
> 1. **Lane**
>
> ### 2. Concurrent Mode （并发模式）



## Fiber Reconciler

15 是 Stack Reconciler

> 如果页面足够复杂，栈很深，就会执行函数直到栈清空，js一直执行，浏览器得不到控制权，就不能及时开始下一帧的绘制，超过16ms就会动画出现卡顿，因为事件响应代码是在每一帧开始时执行，就会导致事件响应也延迟

16 是 Fiber Reconciler

> 将耗时长的任务分成很多小片，每一个片运行时间很短，每一小片执行完之后会把控制权给负责任务协调的模块，看看有没有紧急任务要做，如果有就紧急任务，如果没有，继续更新

#### Fiber链式结构

> 优点：
>
> 1. 操作高效，改变指针指向来调整顺序、删除
> 2. 多向链表还能找父节点和兄弟节点
>
> 缺点：用空间换时间



## Fiber 如果实现更新过程可控

1. 任务拆分

2. 任务挂起、恢复、终止

   >挂起：
   >
   >执行完一个小任务后，先判断这一帧是否还有空闲时间，没有就挂起下一个任务，记住当前挂起的节点，把控制权给浏览器执行更高优先级的任务
   >
   >恢复：
   >
   >在浏览器渲染完一帧后，判断是否还有剩余时间，有的话恢复执行挂起的任务。没有任务的话，进入渲染阶段
   >
   >终止：
   >
   >高优先级任务会终止下一个要执行的任务，创建一个信的workInProgressFiber树开始构建过程

3. 任务具备优先级

   > 在创建或更新FiberNode时，给每个任务分配了一个到期时间（exporationTime）。
   >
   > 如果已过期，无论是否有刷新帧的空闲时间都必须执行任务。
   >
   > 过期时间的代表还代表着任务的优先级



## 浏览器一帧里面发生的事情

1. 接手输入事件
2. 执行时间回调
3. 开始一帧
4. 执行RAF（RequestAnimationFrame）
5. 页面布局，样式计算
6. 绘制渲染
7. 执行RIC（RequestIdelCallback）

## 参考资料

1. https://segmentfault.com/a/1190000039682751

   

